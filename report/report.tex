\documentclass[11pt,a4paper]{article}

\usepackage[hidelinks]{hyperref}
\usepackage{color}
\usepackage{alltt}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{multicol}
\usepackage{graphicx}

\setlength{\textwidth}{16.5cm}
\setlength{\textheight}{24cm}
\setlength{\parindent}{1em}
\setlength{\parskip}{0pt plus 1pt}
\setlength{\oddsidemargin}{0cm}
\setlength{\evensidemargin}{0cm}
\setlength{\topmargin}{-1.1cm}
\setlength{\headsep}{20pt}
\setlength{\columnsep}{1.5pc}
\setlength\columnseprule{.4pt}
\setlength\premulticols{6\baselineskip}
\pagestyle{fancy}

\setlength{\textwidth}{16.5cm}
\setlength{\textheight}{24cm}
\setlength{\parindent}{1em}
\setlength{\parskip}{0pt plus 1pt}
\setlength{\oddsidemargin}{0cm}
\setlength{\evensidemargin}{0cm}
\setlength{\topmargin}{-1.1cm}
\setlength{\headsep}{20pt}
\setlength{\columnsep}{1.5pc}
\setlength\columnseprule{.4pt}
\setlength\premulticols{6\baselineskip}
\pagestyle{fancy}

\definecolor{gray_ulisses}{gray}{0.55}
\definecolor{castanho_ulisses}{rgb}{0.71,0.33,0.14}
\definecolor{preto_ulisses}{rgb}{0.41,0.20,0.04}
\definecolor{green_ulises}{rgb}{0.2,0.75,0}

\long\def\ignore#1{}
%% Language def and formatting from: http://searchcode.com/codesearch/view/17503576
\lstdefinelanguage{HaskellUlisses}
{
	basicstyle=\ttfamily\scriptsize,
	%backgroundcolor=\color{yellow},
	%frameshape={RYRYNYYYY}{yny}{yny}{RYRYNYYYY}, %contornos... muito nice...
	sensitive=true,
	morecomment=[l][\color{gray_ulisses}\scriptsize]{--},
	morecomment=[s][\color{gray_ulisses}\scriptsize]{\{-}{-\}},
	morestring=[b]",
	stringstyle=\color{red},
	showstringspaces=false,
	numbers=left,
	firstnumber=\thelstnumber,
	numberstyle=\tiny,
	numberblanklines=true,
	showspaces=false,
	showtabs=false,
	xleftmargin=15pt,
	xrightmargin=-20pt,
	emph=
	{[1]
		FilePath,IOError,abs,acos,acosh,all,and,any,appendFile,approxRational,asTypeOf,asin,
		asinh,atan,atan2,atanh,basicIORun,break,catch,ceiling,chr,compare,concat,concatMap,
		const,cos,cosh,curry,cycle,decodeFloat,denominator,digitToInt,div,divMod,drop,
		dropWhile,either,elem,encodeFloat,enumFrom,enumFromThen,enumFromThenTo,enumFromTo,
		error,even,exp,exponent,fail,filter,flip,floatDigits,floatRadix,floatRange,floor,
		fmap,foldl,foldl1,foldr,foldr1,fromDouble,fromEnum,fromInt,fromInteger,fromIntegral,
		fromRational,fst,gcd,getChar,getContents,getLine,head,id,inRange,index,init,intToDigit,
		interact,ioError,isAlpha,isAlphaNum,isAscii,isControl,isDenormalized,isDigit,isHexDigit,
		isIEEE,isInfinite,isLower,isNaN,isNegativeZero,isOctDigit,isPrint,isSpace,isUpper,iterate,
		last,lcm,length,lex,lexDigits,lexLitChar,lines,log,logBase,lookup,map,mapM,mapM_,max,
		maxBound,maximum,maybe,min,minBound,minimum,mod,negate,not,notElem,null,numerator,odd,
		or,ord,otherwise,pi,pred,primExitWith,print,product,properFraction,putChar,putStr,putStrLn,quot,
		quotRem,range,rangeSize,read,readDec,readFile,readFloat,readHex,readIO,readInt,readList,readLitChar,
		readLn,readOct,readParen,readSigned,reads,readsPrec,realToFrac,recip,rem,repeat,replicate,return,
		reverse,round,scaleFloat,scanl,scanl1,scanr,scanr1,seq,sequence,sequence_,show,showChar,showInt,
		showList,showLitChar,showParen,showSigned,showString,shows,showsPrec,significand,signum,sin,
		sinh,snd,span,splitAt,sqrt,subtract,succ,sum,tail,take,takeWhile,tan,tanh,threadToIOResult,toEnum,
		toInt,toInteger,toLower,toRational,toUpper,truncate,uncurry,undefined,unlines,until,unwords,unzip,
		unzip3,userError,words,writeFile,zip,zip3,zipWith,zipWith3
	},
	emphstyle={[1]\color{blue}},
	emph=
	{[2]
		Bool,Char,Double,Either,Float,IO,Integer,Int,Maybe,Ordering,Rational,Ratio,ReadS,ShowS,String
	},
	emphstyle={[2]\color{castanho_ulisses}},
	emph=
	{[3]
		case,class,data,deriving,do,else,if,import,in,infixl,infixr,instance,let,
		module,of,primitive,then,type,where
	},
	emphstyle={[3]\color{preto_ulisses}\textbf},
	emph=
	{[4]
		quot,rem,div,mod,elem,notElem,seq
	},
	emphstyle={[4]\color{castanho_ulisses}\textbf},
	emph=
	{[5]
		EQ,False,GT,Just,LT,Left,Nothing,Right,True,Show,Eq,Ord,Num
	},
	emphstyle={[5]\color{preto_ulisses}\textbf}
}

\lstnewenvironment{code}
{\textbf{} \hspace{0.2cm} \hrulefill \lstset{language=HaskellUlisses}}
{\hrule\smallskip \vspace{1em}}

%% stuff do minitoc %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newenvironment{mtc}{\secttoc\sectlof\sectlot}{\pagebreak}
%                        ^       ^        ^
%                    conteudos  figuras  tabelas
\newenvironment{mtc}{\secttoc\sectlof}{\pagebreak}

\newcommand{\vdag}{(v)^\dagger}
\newcommand{\myemail}{yuhf3@mcmaster.ca}

\begin{document}

\title{A J0 to LLVM Compiler in Haskell}
\author{dreamycactus}
\maketitle
\begin{abstract}
For the undergraduate senior compilers course final project, J0 to LLVM compiler was implemented 
in Haskell. The J0 toy language consists of a subset of the Java language stripped down to the most
essential features. The compiler code was documented using literate
programming techniques and open sourced on Github as an additional reference to novice compilers 
construction in Haskell.
\end{abstract}

\section{Introduction}
The primary goal in this project was to learn about and implement the main
components of compilers while demonstrating good software practices including
proper documentation, modularization, and readability to name a few. The compiler's input
language, J0 is a tiny toy language\href{http://gist.github.com/dreamycactus/20eac37eda6d954315db#file-gistfile1-txt}{(ENBF here)} with Java-like syntax which is
then compiled into the LLVM Intermediate Representation (LLVM IR).
From here users can convert IR into bitcode with the LLVM toolchain.
(LLVM-as in this case).

\section{LLVM}
The LLVM Project consists of resuable compiler and toolchain technologies which
all started from a research project at the University of Illinois.LLVM Intermediate
Representation(LLVM IR) is a relatively high level intermediate representation supporting an
static single assignment form (SSA)-based compilation strategy capable of static and dynamic
compilation. The essential idea behind SSA is that each variable is assigned to only once, allowing
certain compiler optimizations to be done cheaply.\\

LLVM's bitstream
file format is identified and verified by ``magic number'' bits. The file itself
consists of blocks and records. There are many types of blocks, with basic blocks
which roughly correspond to labels in assembly, and blocks that contain function bodies.
Data records which contain a record code and a number keep track of data objects and describe
entities in the file.

\section{Approach}
The main components of the J0 compiler are shown in the below diagram. Lexing and Parsing will be implemented
using Haskell's Parsec library, and the Analyzer and Code Generator will use llvm-general Haskell bindings.


\subsection{Parsing}
The J0 compiler is implemented in Haskell, which provides a few benefits over C. Haskell allows for
elegant parsing, particularly with the aid of the Parsec parsing library. Parsec contains various features
that support top-down recursive descent parsing in addition to other methods and handles details such as 
lookahead characters
and provides many useful parsing aids. The \emph{<|>} operator implements choice
in parsing. 

\subsection{Documentation}
Haskell has native support for literate programming. Haskell code conforming to the principles of literate
programming use the file extension .lhs rather than .hs. Most of J0 compiler's code is written in this
format. From .lhs files, there are latex utilities, namely lhs2tex, that then format and present the 
literate program.

\section{Resources}
The canonical Dragon book was be used as the primary academic resource for the construction of the J0 compiler.
Let's Build A Compiler, written by Jack Crenshaw was used as a resource for more practical aspects of compiler
construction. Source code repositories \url{https://github.com/sdiehl/kaleidoscope} and 
\url{https://github.com/alephnullplex/cradle} were excellent resources which had well documented code for
a JIT compiler for Kaleidoscope and Pascal0 respectively.

\section{Acknowledgements}
Much of the code was based on Stephen Diel's Haskell LLVM tutorials, which without, it would have been much more
difficult getting started with this project. The attribute grammar for the language was based on the minijava compiler repository on Github.

\section{Implementation Overview}
\subsection{Features}
The single pass j0 compiler takes an input .j0 file, and outputs the corresponding LLVM IR. It can also work interactively taking input via command line, as long as the input code is given appropriate chunks (at a class definition granularity). Were this a fully featured and more practical compiler, the compiler should output LLVM bitcode rather than IR. As it stands, an extra step is required to generate the bitcode from the IR.

\subsection{Limitations and Problems}
There are quite a number of bugs at this moment with the tool. In particular, bugs relating to symbol conflicts are not caught by the tool. For example one can define a class member ``a'' then a class function ``a'' in the same class, and the compiler will not complain. However during conversion of IR to bitcode, the LLVM llc tool detects the problem. \\ \\

Another problem is that each class function is available at global scope. This is due to proper class method calling not being fully implemented.\\ \\

One other big problem is the lack of type checking. llvm-general constructs do some type checking via its operands internally, but is not a complete type checking solution. For example, we can use an object as a condition, which is simply nonsense. The compiler will not detect this, but llc will.

Due to time constraints, I did not implement code generation for boolean logic and unary and binary comparison operators. They are, however, being parsed correctly. In addition, the only control statement that emits code is the if statement. There is no code generation for loops. All of these features should be trivial to implement as will be seen further below in the source code.

\subsection{High Level Design}
The structure of the j0 compiler is quite simple. The program primarily consists of the following modules: Lexer, Syntax Definitions, Parser, Codegeneration backend, and Code emitter. Their functions should be self explanatory. The compiler flow is as follows: \\
\begin{center}
 \includegraphics[width=260px,height=100px,bb=0 0 919 132,keepaspectratio=true]{./flow.png}
 % flow.png: 919x132 pixel, 72dpi, 32.42x4.66 cm, bb=0 0 919 132
\end{center}
The Parsec library is used in lexing and parsing, and the llvm-general library is used for to emit IR from an LLVM Module data structure which contains all the translated definitions from the input source.

%% thebibliography produces citations in the text using \bibitem-\cite
%% cross-referencing. Each reference is preceded by a
%% \bibitem command that defines in curly braces the KEY that corresponds
%% to the KEY in the \cite commands (see the first section above).
%% Make sure that you provide a unique KEY for every \bibitem or else the
%% paper will not LaTeX. The square brackets should contain
%% the citation text that LaTeX will insert in
%% place of the \cite commands.

\input{../src/Lexert.lhs}
\input{../src/SyntaxMini.lhs}
\input{../src/ParserMini.lhs}
\input{../src/Codegen.lhs}
\input{../src/Emit.lhs}
\input{../src/Main.lhs}

\section{Concluding Thoughts}
I think I have learned quite a bit writing this compiler. Everything was a bit new to me, even Haskell itself to some extent. There were many potential features that could have been implemented, but all in all, I think this project will serve as a reasonble reference to other undergraduate students taking compilers.

\begin{thebibliography}{9}

\bibitem[dragon(2007)]{dragon} 
    \emph{Compilers: principles, techniques, and tools 2nd ed 2007},
    Addison-Wesley Longman Publishing Co.,
    Alfred V. Aho, Ravi Sethi, \& Jeffrey D. Ullman.
\bibitem[lbac(1995)]{lbac} 
    \emph{Let's Build A Compiler 1995},
    I.E.C.C.,
    Jack Crenshaw.
\bibitem[ssa(2014)]{ssawiki} 
    \emph{Static single assignment form 2014},
    Wikipedia,
    \url{http://en.wikipedia.org/wiki/Static_single_assignment_form}
\bibitem[llvm(2014)]{llvmbit} 
    \emph{LLVM Bitcode File Format 2014},
    LLVM Reference,
    \url{http://llvm.org/docs/BitCodeFormat.html}
\bibitem[llvm(2014)]{llvmmain} 
    \emph{The LLVM Compiler Infrastructure 2014},
    LLVM Site,
    \url{http://llvm.org/}
\end{thebibliography}

\clearpage

\end{document}

%%
%% End of file `sample.tex'.
